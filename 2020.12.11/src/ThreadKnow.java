/**
 * @program: 2020.12.11
 * @description: 多线程8
 * @author: spdz
 * @create: 2020-12-08 18:40
 **/

/**
 * 《如何写出一个线程安全的代码》
 *  1.首先分析，代码中是否需要特意考虑线程不安全的情况
 *      1. 考虑为什么必须要用多线程!    不要滥用多线程
 *      2.需要用到多线程了，是否可以让线程之间不进行数据的共享，各干各的
 *      3.必须共享的情况下，能否让共享数据只读
 *  2.必须有多线程 且有共享 且必须修改
 *      一定需要从 原子性/内存可见性/代码重排序 角度分析代码中哪里有隐患
 *  3.使用以下讲解的办法，解决代码中的线程不安全隐患。
 */

/**
 * 保证线程安全的机制：
 *  1.synchronized 关键字 --同步
 *      修饰方法 --同步方法 --相当于 没有被修饰 的方法，内部加了 被修饰 的代码块
 *      修饰代码块 --同步代码块 --让多个线程之间产生同步 --通过锁
 *
 *      synchronized 保证了 原子性，也保证了一定的 内存可见性 和 一定的 代码重排序
 *
 *      一个对象中 除了 其自身属性外，还有 JVM 会用到的管理信息（元数据--mata），
 *      这些信息中 有把锁，这把锁 被称为 同步锁/内部锁/对象锁/监视器锁
 *
 *      一个线程在使用 被synchronized 修饰的东西 时，会在 开始时，
 *      请求 这个对象中的 锁，任务结束后 释放锁，中间被称为 临界区
 *      在锁被释放之前，其他线程 在使用 被synchronized 修饰的东西 时，
 *      即使被分配了CPU ，也会因为 申请不到 这个对象中的 锁，而放弃CPU，
 *      并且 放弃抢 CPU 的资格，这便是--BLOCKED 状态，保证了 原子性（不可分割）
 *
 *      判断 线程 之间 是否同步
 *          1.看 是不是 都被 synchronized 修饰（加锁动作）
 *          2.看 加锁 是不是加的 同一把锁（同一对象）
 *
 *  2.volatile 关键字 -- 易失的
 *      修饰的是 共享的变量（属性 和 静态属性）
 *
 *      volatile 保证了 内存可见性，也保证了一定的 原子性 和 一定的 代码重排序
 *
 *      被 volatile 修饰的 变量，都必须从 主内存中读取，
 *                  对其的修改，必须同步回 主内存，保证了 内存可见性
 *
 *      long、duoble 不具备原子性，
 *      但加上 volatile 后，保证了 原子性，volatile 只保证这两个的原子性
 *
 *      被 volatile 修饰后，仅 实例化对象时，不能 代码重排序
 *
 *  3.wait/notify 机制
 *      wait()/notify() 是 Object 的一个普通方法，凡是用到wait()/notify()，
 *      都必须先通过 synchronized 对 调用 wait()/notify() 的 对象 加锁
 *
 *      一个对象（例如 A 对象） 的 元数据 中除了有一把锁，还有个 等待集，
 *      当一个线程 .wait() 后，线程放弃 CPU，并放弃抢CPU 资格（WAITING 状态），
 *      将自己 放入 等待集，当另一个线程 .notify() 后，从 等待集 随机释放
 *
 *      wait() 会 额外 释放锁，请求锁，notify() 没有
 *      synchronized(a) { 请求锁
 *          释放锁
 *          o.wait();
 *          请求锁
 *      } 释放锁
 */

public class ThreadKnow {

}
